---
title: "Long Terminal Repeat (LTR) (including endogenous retroviruses, ERV) Retrotransposons analysis"
author: "Christelle Colin-Leitzinger"
date: '`r Sys.Date()`'
output: 
  html_document:
    toc: true
    toc_float: true
    toc_collapsed: false
    theme: united
    code_folding: hide
    highlight: pygments
    df_print: paged
editor_options: 
  chunk_output_type: console
---

<style type="text/css">

.figure {
   margin-top: 25px;
   margin-bottom: 100px;
}

table {
    margin-top: 10px;
    margin-bottom: 25px;
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(
                      warning = FALSE,
                      message = FALSE,
                      cache = FALSE,
                      fig.align='center'
                      )
```

```{r library, echo = FALSE}
library(tidyverse)
library(naniar)
library(ComplexHeatmap)
library(gtsummary)
library(survival)
library(survminer)
# if (!require("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
# 
# BiocManager::install("IlluminaHumanMethylationEPICanno.ilm10b2.hg19")
theme_gtsummary_compact()
theme_set(theme_classic())
```

<style>
div.darkblue { background-color:#0099CC; border-radius: 5px; padding: 20px; font-size: 38px}
</style>
<div class = "blue">

<span style="color: white;">LTR/ERV Retrotransposons analysis in AACES and NCOCS data</span>

</div>
<br>

```{r load}
load(paste0(here::here(), "/cleaned_07082022.rda"))
```

# I. Exploratory analysis
## Let's take a look at the data
The clean data was normalized (showing just several patient samples)
```{r, echo = FALSE}
summary(betas_clean6)[,1:9]
```
Each row represent a CpG probe (601957 unique probe) and each column should represent sample (202).
```{r, echo = FALSE}
str(betas_clean6)
```
I assume that the sample name ends by `R0` (red probe) because of a copy paste of previous cleaning.  
<br>

Looking a little deeper.
The data contain missing values (the heatmap below only shows 50 samples for 50 cpg)
```{r, echo = FALSE}
betas_clean6 %>% skimr::skim()
```

```{r, echo = FALSE}
vis_miss(betas_clean6[1:50, 1:50] %>% as_tibble())
```
The first step is to impute those missing value using the `grooMethy()` function.
<span style="color: red;">Is that correct?</span>

# II. Imputation with `grooMethy()`

<span style="color: purple;">From the intro of REMP pdf vignette:
For zero beta values, grooMethy will replace them with smallest non-zero beta value. For one beta values, grooMethy will replace them with largest non-one beta value. For NA/NaN/Inf values, grooMethy will treat them as missing values and then apply KNN-imputation to complete the dataset. If the imputed value is out of the original range (which is possible when imputebyrow = FALSE), mean value will be used instead. Warning: imputed values for multimodal distributed CpGs (across samples) may not be correct. Please check package ENmix to identify the CpGs with multimodal distribution. <span style="color: red;">I think you already eliminated multimodal samples</span> For sequencing data, the users only need to prepare a methylation data matrix (row = CpGs, column = samples). The corresponding CpG location information (either in hg19 or hg38) should be prepared in a separate GRanges object and provide it to the Seq.GR argument in grooMethy.</span>
<span style="color: red;">From what I understood, I don't need to furnish the CpG location info. Correct?</span>
```{r, class.source = 'fold-show'}
library(REMP)
citation("REMP")
# getLocations(IlluminaHumanMethylationEPICanno.ilm10b4.hg19)      # NOT RUN
# genomic_location_matrix <- getLocations(IlluminaHumanMethylationEPICanno.ilm10b4.hg19)      # NOT RUN
# groomed_data <- grooMethy(beta_data, Seq.GR = genomic_location_matrix)      # NOT RUN

# groomed_data <- grooMethy(betas_clean6)
# write_rds(groomed_data, "groomed_data.rds")
groomed_data <- read_rds(paste0(here::here(), "/intermediary data/groomed_data.rds"))
```

The data has the same dimension `r dim(groomed_data)` but is now imputed (just show 50x50 plot).
```{r, echo = FALSE}
a <- groomed_data@assays@data@listData
vis_miss(a[["Beta"]][1:50, 1:50] %>% as_tibble())
```

# III. Prepare annotation data
Need to prepare annotation for each RE type : "Alu", "L1", "ERV" (Human (hg19/hg38) Alu, LINE-1 (L1), and Long Terminal Repeat (LTR) (including endogenous retroviruses, ERV) repetitive element (RE) methylation)
```{r, class.source = 'fold-show'}
library(IlluminaHumanMethylationEPICanno.ilm10b2.hg19)
citation("IlluminaHumanMethylationEPICanno.ilm10b2.hg19")
# remparcel_ERV <- initREMP(arrayType = "EPIC", 
#                       REtype = "ERV",
#                       annotation.source = "AH", 
#                       genome = "hg19", 
#                       ncore = 1)
# remparcel_ERV
# saveParcel(remparcel_ERV, work.dir = here::here())
```

# IV. Run prediction
```{r, class.source = 'fold-show'}
# remp_res_ERV <- remp(groomed_data,
#                  REtype = 'ERV',
#                  parcel = remparcel_ERV, ncore = 4, seed = 1234,
#                  work.dir = here::here())
# write_rds(remp_res_ERV, "intermediary data/remp_results_ERV.rds")
remp_res_ERV <- read_rds(paste0(here::here(), "/intermediary data/remp_results_ERV.rds"))
```

## Explore results
The data dimension is `r dim(remp_res_ERV)`.
```{r, class.source = 'fold-show'}
remp_res_ERV
# Display more detailed information
details(remp_res_ERV)
# Now have 564589 rows
remp_res_ERV@rowRanges@elementMetadata@nrows
# they are :
remp_res_ERV@rowRanges@elementMetadata
```

We have multiple instance for 1 RE type:
```{r}
remp_res_ERV@rowRanges@elementMetadata %>% as_tibble() %>% 
  tbl_summary()

remp_res_ERV@rowRanges@elementMetadata %>% as_tibble() %>% 
  group_by(RE.Index) %>%
  mutate(count = n()) %>%
  ungroup() %>%
  distinct() %>%
  select(count) %>% 
  tbl_summary(type = list(everything() ~ "categorical"))
```

## Metadata
```{r, class.source = 'fold-show'}
remp_res_ERV@metadata
```
For this reason, and even if it is an optional step, it is probably a good idea to aggregate the B value at the end of the process.  
<span style="color: red;">What are your thoughts?</span>

## Plot var imp
What are the important measurement available?
```{r, class.source = 'fold-show'}
var_imp <- remp_res_ERV@metadata[["varImp"]]
rownames(var_imp)
```

```{r, echo = FALSE}
var_imp1 <- var_imp %>% as_tibble(rownames = "patient_id")

var_imp2 <- var_imp1 %>% column_to_rownames("patient_id") %>% t()
var_imp3 <- var_imp2 %>% as_tibble() %>%
  mutate(patient_id = colnames(var_imp), .before=1)

var_imp3 %>%
  mutate(all_patients = "all patients") %>%
  ggplot(aes(x=all_patients, y=RE.swScore))+
  geom_boxplot()+
  geom_jitter()
var_imp3 %>%
  mutate(all_patients = "all patients") %>%
  ggplot(aes(x=all_patients, y=RE.Length))+
  geom_boxplot()+
  geom_jitter()
var_imp3 %>%
  mutate(all_patients = "all patients") %>%
  ggplot(aes(x=all_patients, y=RE.CpG.density))+
  geom_boxplot()+
  geom_jitter()

```


## B value
Let's take a quick look at the data (used only 200 ERV in the heatmaps - to fit html).
```{r, class.source = 'fold-show'}
# Prediction results can be obtained by accessors:
# Predicted RE-CpG methylation value (Beta value)
ERV_beta_results <- rempB(remp_res_ERV)
ERV_beta_results1 <- ERV_beta_results %>% as_tibble() %>%
  cbind(ERV = remp_res_ERV@rowRanges@elementMetadata$RE.Index, .)

```
The B value data dimension is still `r dim(ERV_beta_results)`.

```{r, fig.height=12, fig.width=12, echo = FALSE}
map_df <- ERV_beta_results1[1:200,] %>% group_by(ERV) %>% mutate(type = row_number())

map_df1 <- map_df %>%
  unite(ERV, c(ERV, type)) %>%
  column_to_rownames("ERV")
df_map1 <- t(scale(t(as.matrix(map_df1)))) # scale for standardizing the data to make variables comparable
# column_ho = HeatmapAnnotation(is_lipids = c(map_df$is_lipids),
#                               col = list(is_lipids = c("Yes" = "#932667FF", "No" = "grey")),
#     na_col = "black")
Heatmap(df_map1, name = " ",
        na_col = "black"
        # cluster_rows = FALSE,
        # cluster_columns = FALSE#,
        # top_annotation = column_ho
        )
```

<!-- ## M value -->
<!-- <span style="color: red;">Which condition are we working more with M value instead of B value?</span>   -->
<!-- ```{r, class.source = 'fold-show'} -->
<!-- #Predicted RE-CpG methylation value (M value) -->
<!-- rempM(remp_res_ERV) -->

<!-- # Genomic location information of the predicted RE-CpG -->
<!-- # Function inherit from class 'RangedSummarizedExperiment' -->
<!-- rowRanges(remp_res_ERV) -->
<!-- # Standard error-scaled permutation importance of predictors -->
<!-- rempImp(remp_res_ERV) -->
<!-- ``` -->

# V. Trimming
```{r, class.source = 'fold-show'}
# Trim off less reliable predicted results:
# Any predicted CpG values with quality score less than
# threshold (default=1.7) will be replaced with NA.
# CpGs contain more than missing Rate*100% (default=20%)
# missing rate across samples will be discarded.
remp_res_ERV <- rempTrim(remp_res_ERV,threshold=1.7,missingRate=0.2)
details(remp_res_ERV)
trimmed_ERV_beta_results <- rempB(remp_res_ERV)
```
The trimmed B value data has a reduced number of RE. The dimension is now `r dim(trimmed_ERV_beta_results)`.

```{r, fig.height=12, fig.width=12, echo = FALSE}
trimmed_ERV_beta_results <- trimmed_ERV_beta_results %>% as_tibble() %>%
  cbind(ERV = remp_res_ERV@rowRanges@elementMetadata$RE.Index, .)
map_df <- trimmed_ERV_beta_results[1:200,] %>% group_by(ERV) %>% mutate(type = row_number())

map_df1 <- map_df %>%
  unite(ERV, c(ERV, type)) %>%
  column_to_rownames("ERV")
df_map1 <- t(scale(t(as.matrix(map_df1)))) # scale for standardizing the data to make variables comparable
# column_ho = HeatmapAnnotation(is_lipids = c(map_df$is_lipids),
#                               col = list(is_lipids = c("Yes" = "#932667FF", "No" = "grey")),
#     na_col = "black")
Heatmap(df_map1, name = " ",
        na_col = "black"
        # cluster_rows = FALSE,
        # cluster_columns = FALSE#,
        # top_annotation = column_ho
        )
```
As before, the trimmed data still shows multiple instance for 1 RE type (here the first 20 rows):
```{r}
trimmed_ERV_beta_results$ERV[1:20]
```

# VI. Aggregating RE
Even if optional (per the package vignettes), I think this is a good idea to aggregate values for the same RE.
```{r, class.source = 'fold-show'}
# (Optional) Aggregate the predicted methylation of CpGs in RE by averaging them to obtain the RE-specific methylation level:
# remp_res_ERV <- rempAggregate(remp_res_ERV, NCpG = 2, ncore = 4)
# write_rds(remp_res_ERV, "intermediary data/remp_res_ERV_aggregate.rds")
remp_res_ERV <- read_rds(paste0(here::here(), "/intermediary data/remp_res_ERV_aggregate.rds"))
details(remp_res_ERV)
# Aggregating CpGs in the same RE for RE-level methylation data is beneficial because 1) it greatly reduces the
# data dimension for downstream analysis and 2) it may produce more robust RE methylation estimation. Note that
# by default, RE with 2 or more predicted CpG sites will be aggregated. Therefore, the downside of doing this is the
# reduced coverage of RE. The assumption of doing this is the CpG methylation level within each RE are similar.
aggr_ERV_beta_results <- rempB(remp_res_ERV)
```
The aggregate B value data has again a reduced number of RE. The dimension is now `r dim(aggr_ERV_beta_results)`.

It doesn't shows multiple instance for 1 RE type anymore (here the first 20 rows):
```{r}
aggr_ERV_beta_results <- aggr_ERV_beta_results %>% as_tibble() %>%
  cbind(ERV = remp_res_ERV@rowRanges@elementMetadata$RE.Index, .)
aggr_ERV_beta_results$ERV[1:20]
```

```{r, fig.height=12, fig.width=12, echo = FALSE}
map_df <- aggr_ERV_beta_results[1:200,] %>% group_by(ERV) %>% mutate(type = row_number())

map_df1 <- map_df %>%
  unite(ERV, c(ERV, type)) %>%
  column_to_rownames("ERV")
df_map1 <- t(scale(t(as.matrix(map_df1)))) # scale for standardizing the data to make variables comparable
# column_ho = HeatmapAnnotation(is_lipids = c(map_df$is_lipids),
#                               col = list(is_lipids = c("Yes" = "#932667FF", "No" = "grey")),
#     na_col = "black")
Heatmap(df_map1, name = " ",
        na_col = "black"
        # cluster_rows = FALSE,
        # cluster_columns = FALSE#,
        # top_annotation = column_ho
        )
```

# VII. Annotation
This step reintroduce some NAs.
```{r, class.source = 'fold-show'}
# To add genomic regions annotation of the predicted REs:
# By default gene symbol annotation will be added
# remp_res_ERV <- decodeAnnot(remp_res_ERV, ncore = 4)
# write_rds(remp_res_ERV, "intermediary data/remp_res_ERV_annotation.rds")
remp_res_ERV <- read_rds(paste0(here::here(), "/intermediary data/remp_res_ERV_annotation.rds"))

# 4. Plot prediction
remplot(remp_res_ERV, main = "ERV methylation", col = "blue")

annot_ERV_beta_results <- rempB(remp_res_ERV)
```
The annotated B value data dimension doesn't change from the previous step : `r dim(annot_ERV_beta_results)`.

```{r, fig.height=12, fig.width=12, echo = FALSE}
annot_ERV_beta_results <- annot_ERV_beta_results %>% as_tibble() %>%
  cbind(Index = remp_res_ERV@rowRanges@elementMetadata$RE.Index, .)
map_df <- annot_ERV_beta_results[1:200,]

map_df1 <- map_df %>%
  column_to_rownames("Index")
df_map1 <- t(scale(t(as.matrix(map_df1)))) # scale for standardizing the data to make variables comparable

Heatmap(df_map1, name = " ",
        na_col = "black"
        # cluster_rows = FALSE,
        # cluster_columns = FALSE#,
        # top_annotation = column_ho
        )
```

<span style="color: red;">I am not sure if this is the easiest way of linking the B values to the annotations. Please could you check it out.</span>
```{r join Bvalue gene chr info, class.source = 'fold-show'}
ERV_beta_results <-
  annot_ERV_beta_results %>%
  # Merge with annotation, get #chr, start, end
  left_join(., as_tibble(rempAnnot(remp_res_ERV)), by = "Index")
  
ERV_beta_results <- ERV_beta_results %>% 
  mutate(symbol = coalesce(InNM.symbol, InNR.symbol, InTSS.symbol, 
                           In5UTR.symbol, InCDS.symbol, InExon.symbol, 
                           In3UTR.symbol)) 

ERV_beta_results_ <- ERV_beta_results %>% 
  unite(Index, c(Index, seqnames:repName, symbol), sep = "; ") %>% 
  column_to_rownames("Index") %>% 
  select(starts_with("X")) %>% 
  t() %>% as_tibble(rownames = "patient_id")


# write_rds(ERV_beta_results_, "intermediary data/ERV_beta_results.rds")
```
<span style="color: red;">You talked about aggregating the value per gene, correct? I think it will be at this step..Is that right?</span>  
The gene list is in the analysis.  
<span style="color: red;">Do I need to use the data from this step to create the cluster or using the data after the aggregation per gene?</span>  

###

# VIII. Results analysis
## RE Summary
Sorry for the long table, I didn't aggregate the value per gene yet!
```{r, echo = FALSE}
ERV_beta_results %>%
  mutate(seqnames = factor(seqnames)) %>%
  select(seqnames, symbol) %>%
  tbl_summary()
```

<br>

***
<br>

## Clinical analysis
```{r, echo = FALSE}
phenoclean <- phenoclean %>%
  select(-c(starts_with("chr"))) %>%
  remove_rownames() %>%
  mutate(suid = Sample_Name) %>%
  select(-c(Sample_Name, roi_num : Basename))

phenoclean <- phenoclean %>%
  mutate(bmi_cat = case_when(
    BMI_recent < 25                                         ~ "<25",
    BMI_recent >= 25 &
      BMI_recent < 30                                       ~ "25-29",
    BMI_recent >= 30 &
      BMI_recent < 35                                       ~ "30-34",
    BMI_recent >= 35                                        ~ "≥35"
  ), bmi_cat =
    factor(bmi_cat, levels = c("<25", "25-29", "30-34", "≥35"))) %>%
  mutate(vitalstatus = case_when(
    vitalstatus == 1                ~ 0,
    vitalstatus == 2                ~ 1
  ))




ERV_beta_results1 <- ERV_beta_results %>%
  select(Index, seqnames, repName, symbol,
         starts_with("X")) %>%
  unite(Ids, c("Index", "seqnames", "repName", "symbol"))

map_df1 <- ERV_beta_results1 %>%
  column_to_rownames("Ids")
map_df2 <- map_df1 %>% t() %>% as_tibble() %>%
  cbind(patient_id = colnames(map_df1), .) %>%
  mutate(patient_id = str_remove(patient_id, "X"))

ERV_data <- map_df2 %>%
  full_join(phenoclean, ., by = c("Complete.Barcode" = "patient_id"))
```
Quick look at the data
```{r, fig.height=12, fig.width=12, echo = FALSE}
ERV_data
```

Another heatmap for fun!
```{r, fig.height=12, fig.width=12, echo = FALSE}
map_df1 <- ERV_data %>%
  unite(Complete.Barcode, c(Complete.Barcode, bmi_cat, grade,
                            stage, debulking_CA125, karyotype,
                            smokcurrent), sep = "_") %>%
  column_to_rownames("Complete.Barcode") %>%
  select(starts_with("ERV"))


map_df <- map_df1[,1:200] #%>% group_by(ERV) %>% mutate(type = row_number())

df_map1 <- t(scale(as.matrix(map_df)))



column_col = HeatmapAnnotation(bmi_cat = c(ERV_data$bmi_cat),
                              grade = c(ERV_data$grade),
                              stage = c(ERV_data$stage),
                              debulking_CA125 = c(ERV_data$debulking_CA125),
                              karyotype = c(ERV_data$karyotype),
                              smokcurrent = c(ERV_data$smokcurrent),
                              col = list(bmi_cat = c("<25" = "#721F81FF",
                                                     "25-29" = "#FD9567FF",
                                                     "30-34" = "#FEC98DFF",
                                                     "≥35" = "#CD4071FF"),
                                         grade = c("moderately differentiated" = "#31688EFF",
                                                   "poorly differentiated" = "#FFEA46FF"),
                                         stage = c("Distant" = "#721F81FF",
                                                   "Localized" = "#0D0887FF",
                                                   "Regional" = "#F0F921FF"),
                                         debulking_CA125 = c("OPTIMAL" = "white",
                                                             "SUBOPTIMAL" = "grey"),
                                         karyotype = c("Xa" = "#440154FF",
                                                       "XaXa" = "#3B528BFF",
                                                       "XaXi" = "#21908CFF"),
                                         smokcurrent = c("current smoker" = "#5DC863FF",
                                                         "former smoker" = "#FDE725FF",
                                                         "never smoker" = "tomato"),
    na_col = "black"))
row_col = rowAnnotation(Chromosome = c(ERV_beta_results$seqnames[1:200]),
                        Gene = c(ERV_beta_results$symbol[1:200]),
                        col = list(
                          na_col = "black")
)
Heatmap(df_map1, name = " ",
        show_column_names = FALSE,
        show_row_names = FALSE,
        # cluster_rows = FALSE,
        # cluster_columns = FALSE#,
        top_annotation = column_col,
        left_annotation = row_col,
        na_col = "black"
        )
```

<!-- ## Linear regression -->
<!-- <span style="color: red;">Can we model a type of RE? Not sure it is something we can/should look at.</span>   -->
<!-- ```{r} -->
<!-- glm(ERV_0000303_chr1_NM_001282669_DFFB ~ -->
<!--       refage + stage + grade + debulking_CA125 + bmi_cat, -->
<!--     data = ERV_data -->
<!-- ) %>% -->
<!--   tbl_regression(exponentiate = TRUE, -->
<!--                  intercept = TRUE) -->
<!-- ``` -->



<!-- ## Survival -->
<!-- I think we will create categories of RE to add to survival analysis but just for a start... -->
<!-- ```{r} -->
<!-- tbl1 <- ERV_data %>% select(vitalstatus, timelastfu, -->
<!--                             refage, stage, grade, -->
<!--                             debulking_CA125, bmi_cat) %>% -->
<!--   tbl_uvregression(method = survival::coxph, -->
<!--                    y = (Surv(time = ERV_data$timelastfu, -->
<!--                              event = ERV_data$vitalstatus)), -->
<!--                    exponentiate = TRUE) %>% -->
<!--   bold_labels() %>% italicize_levels() %>% -->
<!--   bold_p(t = .05) %>% add_nevent(location = "level") %>% add_n(location = "level") -->
<!-- tbl2 <- -->
<!--   coxph(Surv(time = ERV_data$timelastfu, -->
<!--              event = ERV_data$vitalstatus) ~ -->
<!--           refage + stage + grade + debulking_CA125 + bmi_cat, -->
<!--         data =  ERV_data) %>% -->
<!--   tbl_regression(exponentiate = TRUE) %>% -->
<!--   bold_p(t = .05) %>% -->
<!--   add_nevent(location = "level") %>% add_n(location = "level") -->
<!-- tbl_merge(list(tbl1, tbl2), tab_spanner = c("**Univariable**", "**Multivariable**")) -->
<!-- ``` -->


















***

```{r echo=FALSE, out.width='30%'}
knitr::include_graphics('/Users/colinccm/Documents/GitHub/Peres/lab_logo/Peres hex.png')
```

