---
title: "LINE-1 Retrotransposons analysis"
author: "Christelle Colin-Leitzinger"
date: '`r Sys.Date()`'
output: 
  html_document:
    toc: true
    toc_float: true
    toc_collapsed: false
    theme: united
    code_folding: hide
    highlight: pygments
    df_print: paged
editor_options: 
  chunk_output_type: console
---

<style type="text/css">

.figure {
   margin-top: 25px;
   margin-bottom: 100px;
}

table {
    margin-top: 10px;
    margin-bottom: 25px;
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(
                      warning = FALSE,
                      message = FALSE,
                      cache = FALSE,
                      fig.align='center'
                      )
```

```{r library, echo = FALSE}
library(tidyverse)
library(naniar)
library(ComplexHeatmap)
library(gtsummary)
library(survival)
library(survminer)
# if (!require("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
# 
# BiocManager::install("IlluminaHumanMethylationEPICanno.ilm10b2.hg19")
theme_gtsummary_compact()
theme_set(theme_classic())
```

<style>
div.darkblue { background-color:#0099CC; border-radius: 5px; padding: 20px; font-size: 38px}
</style>
<div class = "blue">

<span style="color: white;">LINE-1 Retrotransposons analysis in AACES and NCOCS data</span>

</div>
<br>

```{r load}
load(paste0(here::here(), "/cleaned_07082022.rda"))
```

<!-- # I. Exploratory analysis -->
<!-- ## Let's take a look at the data -->
<!-- The clean data was normalized (showing just several patient samples) -->
<!-- ```{r, echo = FALSE} -->
<!-- summary(betas_clean6)[,1:9] -->
<!-- ``` -->
<!-- Each row should represent CpG probe (601957) and each column should represent sample (202). -->
<!-- ```{r, echo = FALSE} -->
<!-- str(betas_clean6) -->
<!-- ``` -->
<!-- I assume that the sample name ends by `R0` (red probe) because of a copy paste of previous cleaning.   -->

<!-- Looking a little deeper. -->
<!-- ```{r} -->
<!-- betas_clean6 %>% skimr::skim() -->
<!-- ``` -->

<!-- The data contain missing values (the heatmap below only shows 50 samples for 50 cpg) -->
<!-- ```{r, echo = FALSE} -->
<!-- vis_miss(betas_clean6[1:50, 1:50] %>% as_tibble()) -->
<!-- ``` -->
<!-- The first step is to impute those missing value using the `grooMethy()` function. -->
<!-- <span style="color: red;">Is that correct?</span>   -->

<!-- # II. Imputation with `grooMethy()` -->

<!-- <span style="color: purple;">From the intro of REMP pdf:   -->
<!-- For zero beta values, grooMethy will replace them with smallest non-zero beta value. For one beta values, grooMethy will replace them with largest non-one beta value. For NA/NaN/Inf values, grooMethy will treat them as missing values and then apply KNN-imputation to complete the dataset. If the imputed value is out of the original range (which is possible when imputebyrow = FALSE), mean value will be used instead. Warning: imputed values for multimodal distributed CpGs (across samples) may not be correct. Please check package ENmix to identify the CpGs with multimodal distribution. <span style="color: red;">I think you already eliminated multimodal samples</span> For sequencing data, the users only need to prepare a methylation data matrix (row = CpGs, column = samples). The corresponding CpG location information (either in hg19 or hg38) should be prepared in a separate GRanges object and provide it to the Seq.GR argument in grooMethy.</span>   -->
<!-- <span style="color: red;">From what I understood, I don't need to furnish the CpG location info. Correct?</span>   -->
```{r, class.source = 'fold-show'}
library(REMP)
citation("REMP")
# getLocations(IlluminaHumanMethylationEPICanno.ilm10b4.hg19)      # NOT RUN
# genomic_location_matrix <- getLocations(IlluminaHumanMethylationEPICanno.ilm10b4.hg19)      # NOT RUN
# groomed_data <- grooMethy(beta_data, Seq.GR = genomic_location_matrix)      # NOT RUN

# groomed_data <- grooMethy(betas_clean6)
# write_rds(groomed_data, "groomed_data.rds")
```


```{r}
# groomed_data <- read_rds(paste0(here::here(), "/groomed_data.rds"))
```

<!-- The data is now imputed. -->
<!-- ```{r, echo = FALSE} -->
<!-- a <- groomed_data@assays@data@listData -->
<!-- vis_miss(a[["Beta"]][1:50, 1:50] %>% as_tibble()) -->
<!-- ``` -->

<!-- # III. Prepare annotation data -->
<!-- Need to prepare annotation for each RE type : "Alu", "L1", "ERV" (Human (hg19/hg38) Alu, LINE-1 (L1), and Long Terminal Repeat (LTR) (including endogenous retroviruses, ERV) repetitive element (RE) methylation) -->
<!-- ```{r, class.source = 'fold-show'} -->
<!-- library(IlluminaHumanMethylationEPICanno.ilm10b2.hg19) -->
<!-- citation("IlluminaHumanMethylationEPICanno.ilm10b2.hg19") -->
<!-- remparcel_Alu <- initREMP(arrayType = "EPIC", -->
<!--                       REtype = "Alu", # "L1", "ERV" -->
<!--                       annotation.source = "AH", # "UCSC" -->
<!--                       genome = "hg19", # only option for "AH" -->
<!--                       ncore = 1) -->
<!-- remparcel_Alu -->
<!-- saveParcel(remparcel_Alu, work.dir = here::here()) -->
<!-- remparcel_L1 <- initREMP(arrayType = "EPIC", -->
<!--                       REtype = "L1", -->
<!--                       annotation.source = "AH", -->
<!--                       genome = "hg19", -->
<!--                       ncore = 1) -->
<!-- remparcel_L1 -->
<!-- saveParcel(remparcel_L1, work.dir = here::here()) -->
<!-- remparcel_ERV <- initREMP(arrayType = "EPIC", -->
<!--                       REtype = "ERV", -->
<!--                       annotation.source = "AH", -->
<!--                       genome = "hg19", -->
<!--                       ncore = 1) -->
<!-- remparcel_ERV -->
<!-- saveParcel(remparcel_ERV, work.dir = here::here()) -->
<!-- ``` -->

# IV. Run prediction
```{r, class.source = 'fold-show'}
# remp_res_Alu <- remp(groomed_data, # Need to use BPPARAM = SnowParam(workers = 2)
#                  REtype = 'Alu',
#                  parcel = remparcel_Alu, ncore = 4, seed = 1234,
#                  work.dir = here::here())
# write_rds(remp_res_Alu, "remp_res_Alu.rds")
remp_res_Alu <- read_rds(paste0(here::here(), "/remp_res_Alu.rds"))
# remp_res_L1 <- remp(groomed_data,
#                  REtype = 'L1',
#                  parcel = remparcel_L1, ncore = 4, seed = 1234,
#                  work.dir = here::here())
# write_rds(remp_res_L1, "remp_res_L1.rds")
remp_res_L1 <- read_rds(paste0(here::here(), "/remp_res_L1.rds"))
# remp_res_ERV <- remp(groomed_data,
#                  REtype = 'ERV',
#                  parcel = remparcel_ERV, ncore = 4, seed = 1234,
#                  work.dir = here::here())
# write_rds(remp_res_ERV, "remp_res_ERV.rds")
remp_res_ERV <- read_rds(paste0(here::here(), "/remp_res_ERV.rds"))
```

## Explore results
```{r, class.source = 'fold-show'}
remp_res_L1
# Display more detailed information
details(remp_res_L1)
# Now have 564589 rows
remp_res_L1@rowRanges@elementMetadata@nrows
# they are :
remp_res_L1@rowRanges@elementMetadata

remp_res_L1@metadata
```

## Plot var imp
What are the variables available?
```{r, class.source = 'fold-show'}
var_imp <- remp_res_L1@metadata[["varImp"]]
rownames(var_imp)
```

```{r, echo = FALSE}
var_imp1 <- var_imp %>% as_tibble(rownames = "patient_id")

var_imp2 <- var_imp1 %>% column_to_rownames("patient_id") %>% t()
var_imp3 <- var_imp2 %>% as_tibble() %>%
  mutate(patient_id = colnames(var_imp), .before=1)

var_imp3 %>%
  mutate(all_patients = "all patients") %>%
  ggplot(aes(x=all_patients, y=RE.swScore))+
  geom_boxplot()+
  geom_jitter()
var_imp3 %>%
  mutate(all_patients = "all patients") %>%
  ggplot(aes(x=all_patients, y=RE.Length))+
  geom_boxplot()+
  geom_jitter()
var_imp3 %>%
  mutate(all_patients = "all patients") %>%
  ggplot(aes(x=all_patients, y=RE.CpG.density))+
  geom_boxplot()+
  geom_jitter()

```


## B value
Let's take a quick look at the data (used only 200 L1 in the heatmaps - to fit html).
```{r, class.source = 'fold-show'}
# Prediction results can be obtained by accessors:
# Predicted RE-CpG methylation value (Beta value)
L1_beta_results <- rempB(remp_res_L1)
L1_beta_results1 <- L1_beta_results %>% as_tibble() %>%
  cbind(L1 = remp_res_L1@rowRanges@elementMetadata$RE.Index, .)

```

```{r, fig.height=12, fig.width=12, echo = FALSE}
map_df <- L1_beta_results1[1:200,] %>% group_by(L1) %>% mutate(type = row_number())

map_df1 <- map_df %>%
  unite(L1, c(L1, type)) %>%
  column_to_rownames("L1")
df_map1 <- t(scale(t(as.matrix(map_df1)))) # scale for standardizing the data to make variables comparable
# column_ho = HeatmapAnnotation(is_lipids = c(map_df$is_lipids),
#                               col = list(is_lipids = c("Yes" = "#932667FF", "No" = "grey")),
#     na_col = "black")
Heatmap(df_map1, name = " ",
        # cluster_rows = FALSE,
        # cluster_columns = FALSE#,
        # top_annotation = column_ho
        )
```

<!-- ## M value -->
<!-- <span style="color: red;">Which condition are we working more with M value instead of B value?</span>   -->
<!-- ```{r, class.source = 'fold-show'} -->
<!-- #Predicted RE-CpG methylation value (M value) -->
<!-- rempM(remp_res_L1) -->

<!-- # Genomic location information of the predicted RE-CpG -->
<!-- # Function inherit from class 'RangedSummarizedExperiment' -->
<!-- rowRanges(remp_res_L1) -->
<!-- # Standard error-scaled permutation importance of predictors -->
<!-- rempImp(remp_res_L1) -->
<!-- ``` -->

# V. Trimming
```{r, class.source = 'fold-show'}
# Trim off less reliable predicted results:
# Any predicted CpG values with quality score less than
# threshold (default=1.7) will be replaced with NA.
# CpGs contain more than missing Rate*100% (default=20%)
# missing rate across samples will be discarded.
remp_res_L1 <- rempTrim(remp_res_L1,threshold=1.7,missingRate=0.2)
details(remp_res_L1)
trimmed_L1_beta_results <- rempB(remp_res_L1)
```

```{r, fig.height=12, fig.width=12, echo = FALSE}
trimmed_L1_beta_results <- trimmed_L1_beta_results %>% as_tibble() %>%
  cbind(L1 = remp_res_L1@rowRanges@elementMetadata$RE.Index, .)
map_df <- trimmed_L1_beta_results[1:200,] %>% group_by(L1) %>% mutate(type = row_number())

map_df1 <- map_df %>%
  unite(L1, c(L1, type)) %>%
  column_to_rownames("L1")
df_map1 <- t(scale(t(as.matrix(map_df1)))) # scale for standardizing the data to make variables comparable
# column_ho = HeatmapAnnotation(is_lipids = c(map_df$is_lipids),
#                               col = list(is_lipids = c("Yes" = "#932667FF", "No" = "grey")),
#     na_col = "black")
Heatmap(df_map1, name = " ",
        na_col = "black"
        # cluster_rows = FALSE,
        # cluster_columns = FALSE#,
        # top_annotation = column_ho
        )
```

# VI. Aggregating RE
```{r, class.source = 'fold-show'}
# (Optional) Aggregate the predicted methylation of CpGs in RE by averaging them to obtain the RE-specific methylation level:
# remp_res_L1 <- rempAggregate(remp_res_L1, NCpG = 2, ncore = 4)
# write_rds(remp_res_L1, "remp_res_L1_aggregate.rds")
remp_res_L1 <- read_rds(paste0(here::here(), "/remp_res_L1_aggregate.rds"))
details(remp_res_L1)
# Aggregating CpGs in the same RE for RE-level methylation data is beneficial because 1) it greatly reduces the
# data dimension for downstream analysis and 2) it may produce more robust RE methylation estimation. Note that
# by default, RE with 2 or more predicted CpG sites will be aggregated. Therefore, the downside of doing this is the
# reduced coverage of RE. The assumption of doing this is the CpG methylation level within each RE are similar.
aggr_L1_beta_results <- rempB(remp_res_L1)
```

```{r, fig.height=12, fig.width=12, echo = FALSE}
aggr_L1_beta_results <- aggr_L1_beta_results %>% as_tibble() %>%
  cbind(L1 = remp_res_L1@rowRanges@elementMetadata$RE.Index, .)
map_df <- aggr_L1_beta_results[1:200,] %>% group_by(L1) %>% mutate(type = row_number())

map_df1 <- map_df %>%
  unite(L1, c(L1, type)) %>%
  column_to_rownames("L1")
df_map1 <- t(scale(t(as.matrix(map_df1)))) # scale for standardizing the data to make variables comparable
# column_ho = HeatmapAnnotation(is_lipids = c(map_df$is_lipids),
#                               col = list(is_lipids = c("Yes" = "#932667FF", "No" = "grey")),
#     na_col = "black")
Heatmap(df_map1, name = " ",
        # cluster_rows = FALSE,
        # cluster_columns = FALSE#,
        # top_annotation = column_ho
        )
```

# VII. Annotation
```{r, class.source = 'fold-show'}
# To add genomic regions annotation of the predicted REs:
# By default gene symbol annotation will be added
# remp_res_L1 <- decodeAnnot(remp_res_L1)
# write_rds(remp_res_L1, "remp_res_L1_annotation.rds")
remp_res_L1 <- read_rds(paste0(here::here(), "/remp_res_L1_annotation.rds"))
rempAnnot(remp_res_L1)

# 4. Plot prediction
remplot(remp_res_L1, main = "L1 methylation", col = "blue")

annot_L1_beta_results <- rempB(remp_res_L1)
```

```{r, fig.height=12, fig.width=12, echo = FALSE}
annot_L1_beta_results <- annot_L1_beta_results %>% as_tibble() %>%
  cbind(Index = remp_res_L1@rowRanges@elementMetadata$RE.Index, .)
map_df <- annot_L1_beta_results[1:200,]

map_df1 <- map_df %>%
  column_to_rownames("Index")
df_map1 <- t(scale(t(as.matrix(map_df1)))) # scale for standardizing the data to make variables comparable
# column_ho = HeatmapAnnotation(is_lipids = c(map_df$is_lipids),
#                               col = list(is_lipids = c("Yes" = "#932667FF", "No" = "grey")),
#     na_col = "black")
Heatmap(df_map1, name = " ",
        na_col = "black"
        # cluster_rows = FALSE,
        # cluster_columns = FALSE#,
        # top_annotation = column_ho
        )
```

```{r quick loop to join Bvalue gene chr info, class.source = 'fold-show'}
# Need to bind L1 with chr and symol
# Data results with the B value and RE.Index
L1_beta_results <-
  annot_L1_beta_results %>%
  # Merge with annotation, get #chr, start, end
  left_join(., as_tibble(remp_res_L1@metadata$REannotation), by = c("Index" = "Index"))

# Merge with refgene, get gene symbol
chr_vec <- paste0("chr", c(seq(1, 22, 1)))
data <- data.frame(matrix(nrow=0, ncol=0))
# data <- data.frame(matrix(nrow=1, ncol=0))
for (i in chr_vec){

  data_chr <- L1_beta_results %>%
  filter(seqnames == i) %>%
  # Merge with refgene, get gene symbol
  left_join(., as_tibble(remp_res_L1@metadata$refGene), by = c("seqnames", "strand"), suffix = c("_RE", "_gene")) %>%
    # select RE position within the gene
  mutate(correct_position = case_when(
    start_RE > start_gene &
      end_RE < end_gene         ~ "correct"
  )) %>%
  filter(correct_position == "correct")

  data <- bind_rows(data, data_chr)

}
L1_beta_results <- data
rm(chr_vec, n, i, data, data_chr)
```

# VIII. Results analysis
## RE Summary
Sorry for the long table!
```{r, echo = FALSE}
L1_beta_results %>%
  mutate(seqnames = factor(seqnames)) %>%
  select(seqnames, GeneSymbol) %>%
  tbl_summary()
```


<br>

***
<br>

## Clinical analysis
```{r, echo = FALSE}
phenoclean <- phenoclean %>%
  select(-c(starts_with("chr"))) %>%
  remove_rownames() %>%
  mutate(suid = Sample_Name) %>%
  select(-c(Sample_Name, roi_num : Basename))

phenoclean <- phenoclean %>%
  mutate(bmi_cat = case_when(
    BMI_recent < 25                                         ~ "<25",
    BMI_recent >= 25 &
      BMI_recent < 30                                       ~ "25-29",
    BMI_recent >= 30 &
      BMI_recent < 35                                       ~ "30-34",
    BMI_recent >= 35                                        ~ "≥35"
  ), bmi_cat =
    factor(bmi_cat, levels = c("<25", "25-29", "30-34", "≥35"))) %>%
  mutate(vitalstatus = case_when(
    vitalstatus == 1                ~ 0,
    vitalstatus == 2                ~ 1
  ))




L1_beta_results1 <- L1_beta_results %>%
  select(Index, seqnames, name, GeneSymbol,
         starts_with("X")) %>%
  unite(Ids, c("Index", "seqnames", "name", "GeneSymbol"))

map_df1 <- L1_beta_results1 %>%
  column_to_rownames("Ids")
map_df2 <- map_df1 %>% t() %>% as_tibble() %>%
  cbind(patient_id = colnames(map_df1), .) %>%
  mutate(patient_id = str_remove(patient_id, "X"))

L1_data <- map_df2 %>%
  full_join(phenoclean, ., by = c("Complete.Barcode" = "patient_id"))
```
Quick look at the data
```{r, fig.height=12, fig.width=12, echo = FALSE}
L1_data
```

Another heatmap for fun!
```{r, fig.height=12, fig.width=12, echo = FALSE}
map_df1 <- L1_data %>%
  unite(Complete.Barcode, c(Complete.Barcode, bmi_cat, grade,
                            stage, debulking_CA125, karyotype,
                            smokcurrent), sep = "_") %>%
  column_to_rownames("Complete.Barcode") %>%
  select(starts_with("L1"))


map_df <- map_df1[,1:200] #%>% group_by(L1) %>% mutate(type = row_number())

df_map1 <- t(scale(as.matrix(map_df)))



column_col = HeatmapAnnotation(bmi_cat = c(L1_data$bmi_cat),
                              grade = c(L1_data$grade),
                              stage = c(L1_data$stage),
                              debulking_CA125 = c(L1_data$debulking_CA125),
                              karyotype = c(L1_data$karyotype),
                              smokcurrent = c(L1_data$smokcurrent),
                              col = list(bmi_cat = c("<25" = "#721F81FF",
                                                     "25-29" = "#FD9567FF",
                                                     "30-34" = "#FEC98DFF",
                                                     "≥35" = "#CD4071FF"),
                                         grade = c("moderately differentiated" = "#31688EFF",
                                                   "poorly differentiated" = "#FFEA46FF"),
                                         stage = c("Distant" = "#721F81FF",
                                                   "Localized" = "#0D0887FF",
                                                   "Regional" = "#F0F921FF"),
                                         debulking_CA125 = c("OPTIMAL" = "white",
                                                             "SUBOPTIMAL" = "grey"),
                                         karyotype = c("Xa" = "#440154FF",
                                                       "XaXa" = "#3B528BFF",
                                                       "XaXi" = "#21908CFF"),
                                         smokcurrent = c("current smoker" = "#5DC863FF",
                                                         "former smoker" = "#FDE725FF",
                                                         "never smoker" = "tomato"),
    na_col = "black"))
row_col = rowAnnotation(Chromosome = c(L1_beta_results$seqnames[1:200]),
                        Gene = c(L1_beta_results$GeneSymbol[1:200]),
                        col = list(
                          na_col = "black")
)
Heatmap(df_map1, name = " ",
        show_column_names = FALSE,
        show_row_names = FALSE,
        # cluster_rows = FALSE,
        # cluster_columns = FALSE#,
        top_annotation = column_col,
        left_annotation = row_col,
        na_col = "black"
        )
```

## Linear regression
<span style="color: red;">Can we model a type of RE? Not sure it is something we can/should look at.</span>  
```{r}
glm(L1_0000303_chr1_NM_001242874_PRKCZ ~
      refage + stage + grade + debulking_CA125 + bmi_cat,
    data = L1_data
) %>%
  tbl_regression(exponentiate = TRUE,
                 intercept = TRUE)
```



## Survival
I think we will create categories of RE to add to survival analysis but just for a start...
```{r}
tbl1 <- L1_data %>% select(vitalstatus, timelastfu,
                            refage, stage, grade,
                            debulking_CA125, bmi_cat) %>%
  tbl_uvregression(method = survival::coxph,
                   y = (Surv(time = L1_data$timelastfu,
                             event = L1_data$vitalstatus)),
                   exponentiate = TRUE) %>%
  bold_labels() %>% italicize_levels() %>%
  bold_p(t = .05) %>% add_nevent(location = "level") %>% add_n(location = "level")
tbl2 <-
  coxph(Surv(time = L1_data$timelastfu,
             event = L1_data$vitalstatus) ~
          refage + stage + grade + debulking_CA125 + bmi_cat,
        data =  L1_data) %>%
  tbl_regression(exponentiate = TRUE) %>%
  bold_p(t = .05) %>%
  add_nevent(location = "level") %>% add_n(location = "level")
tbl_merge(list(tbl1, tbl2), tab_spanner = c("**Univariable**", "**Multivariable**"))
```


















***

```{r echo=FALSE, out.width='30%'}
knitr::include_graphics('/Users/colinccm/Documents/GitHub/Peres/lab_logo/Peres hex.png')
```

